문제 64. 카카오 신입 체용 알고리즘 문제 5번 (자카드 유사도)를 구현하기위해 아래의 str1과 str2의 철자를
	 가지고 아래와 같이 결과를 출력하시오 !

	str1 = 'FRANCE'.lower()
	str2 = 'french'.lower()
	
	list1 = []
	for i in range(len(str1)-1):
	    list1.append(str1[i]+str1[i+1])
	print(list1)
	
	list2 = []
	for i in range(len(str2)-1):
	    list2.append(str2[i]+str2[i+1])
	print(list2)

	['fr', 'ra', 'an', 'nc', 'ce']
	['fr', 're', 'en', 'nc', 'ch']




문제 65. 아래의 str1과 str2에서 특수문자와 숫자와 공백을 제거하고 아래와 같이 출력하시오 !

	str1 = 'aa1+aa2'.lower()
	str2 = 'AAAA12'.lower()
	
	list1 = []
	for i in range(len(str1)-1):
	    list1.append(str1[i]+str1[i+1])
	print(list1)
	
	list2 = []
	for i in range(len(str2)-1):
	    list2.append(str2[i]+str2[i+1])
	print(list2)

	['aa', 'a1', '1+', '+a', 'aa', 'a2']
	['aa', 'aa', 'aa', 'a1', '12']



문제 66. 아래의 결과에서 특수문자와 숫자와 공백을 제거해서 출력하시오 !
	
	str1 = 'aa1+aa2'.lower()
	str2 = 'AAAA12'.lower()
	
	list1 = []
	list2 = []
	
	for i in range(len(str1)-1):
	    x = str1[i]+str1[i+1]
	    if x.isalpha() == True:
	        list1.append(x)
	
	for i in range(len(str2)-1):
	    x = str2[i]+str2[i+1]
	    if x.isalpha() == True:
	        list2.append(x)
	
	print(list1)
	print(list2)

	['aa', 'aa']
	['aa', 'aa', 'aa']
	



문제 67. 아래의 두개의 리스트에 교집합의 갯수를 카운트 하시오 !

	from collections import Counter
	
	temp1 = ['fr', 'ra', 'an', 'nc', 'ce']
	temp2 = ['fr', 're', 'en', 'nc', 'ch']
	
	tmp1_co = Counter(temp1)
	tmp2_co = Counter(temp2)
	tmp = tmp1_co & tmp2_co
	inter_count = sum(tmp_inter.values())
	print(inter_count)

	2



문제 68. 아래와 같이 두 집합의 교집합의 갯수와 합집합의 갯수를 출력하시오 !

	from collections import Counter
	
	temp1 = ['fr', 'ra', 'an', 'nc', 'ce']
	temp2 = ['fr', 're', 'en', 'nc', 'ch']
	
	tmp1_co = Counter(temp1)
	tmp2_co = Counter(temp2)
	tmp_inter = tmp1_co & tmp2_co
	tmp_union = tmp1_co | tmp2_co
	inter_count = sum(tmp_inter.values())
	union_count = sum(tmp_union.values())
	print(inter_count)
	print(union_count)

	2
	8



문제 69. 아래의 str1과 str2에 대한 자카드 유사도가 출력되게 하시오 !

	from collections import Counter
	
	str1 = 'FRANCE'.lower()
	str2 = 'french'.lower()
	
	temp1 = []
	temp2 = []
	
	for i in range(len(str1)-1):
	    x = str1[i]+str1[i+1]
	    if x.isalpha() == True:
	        temp1.append(x)
	
	for i in range(len(str2)-1):
	    x = str2[i]+str2[i+1]
	    if x.isalpha() == True:
	        temp2.append(x)

	tmp1_co = Counter(temp1)
	tmp2_co = Counter(temp2)
	tmp_inter = tmp1_co & tmp2_co
	tmp_union = tmp1_co | tmp2_co
	inter_count = sum(tmp_inter.values())
	union_count = sum(tmp_union.values())
	print(round((inter_count/union_count)*65536))

	16384



문제 70. 교집합과 합집합의 갯수가 공집합일때는 1*65536이 출력되게 하시오 !

	str1 = 'FRANCE'.lower()
	str2 = 'french'.lower()
	
	from collections import Counter
	temp1 = []
	temp2 = []
	
	for i in range(len(str1)-1):
	    x = str1[i]+str1[i+1]
	    if x.isalpha() == True:
	        temp1.append(x)
	
	for i in range(len(str2)-1):
	    x = str2[i]+str2[i+1]
	    if x.isalpha() == True:
	        temp2.append(x)
	
	tmp1_co = Counter(temp1)
	tmp2_co = Counter(temp2)
	tmp_inter = tmp1_co & tmp2_co
	tmp_union = tmp1_co | tmp2_co
	inter_count = sum(tmp_inter.values())
	union_count = sum(tmp_union.values())
	if union_count == 0:
	    print(65536)
	else:
	    print(round((inter_count/union_count)*65536))



문제 71. 위에 완성된 코드에 데이터를 아래의 데이터로 수행해보시오 !

	str1 = 'aa1+aa2'
	str2 = 'AAAA12'
	
	def solution(str1,str2):
	    from collections import Counter
	    str1 = str1.lower()
	    str2 = str2.lower()
	    temp1 = []
	    temp2 = []
	
	    for i in range(len(str1)-1):
	        x = str1[i]+str1[i+1]
	        if x.isalpha() == True:
	            temp1.append(x)
	
	    for i in range(len(str2)-1):
	        x = str2[i]+str2[i+1]
	        if x.isalpha() == True:
	            temp2.append(x)
	
	    tmp1_co = Counter(temp1)
	    tmp2_co = Counter(temp2)
	    tmp_inter = tmp1_co & tmp2_co
	    tmp_union = tmp1_co | tmp2_co
	    inter_count = sum(tmp_inter.values())
	    union_count = sum(tmp_union.values())
	    if union_count == 0:
	        return 65536
	    else:
	        return int((inter_count/union_count)*65536)
	
	print(solution(str1,str2))

















■ 3장. 신경망 

	* 3층 신경망의 가중치인 w1, w2, w3를 하나로 모아서 심플하게 코드를 작성하려면 ?
	
		"딕셔너리를 활용하면 된다"


		# 그림 3-_-
		import numpy as np
		
		network = {}
		
		network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
		network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
		network['w3'] = np.array([[4, 6], [5, 7]])
		print(network.keys())
		print(network.values())

	dict_keys(['w1', 'w2', 'w3'])
	dict_values([array([[1, 2],
	       [3, 4],
	       [5, 6]]), array([[3, 5, 7],
	       [4, 6, 8]]), array([[4, 6],
	       [5, 7]])])



문제 64. 위의 코드를 함수로 만들어서 아래와 같이 실행될 수 있게 하시오 ! (함수이름 : init_network())

	def init_network():
	    import numpy as np
	    network = {}
	    network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
	    network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
	    network['w3'] = np.array([[4, 6], [5, 7]])
	    return network
	
	network = init_network()	# 함수를 network이라는 변수에 담는다.
	print(network['w1'])
	
	[[1 2]
	 [3 4]
	 [5 6]]






★ 함수를 변수에 담아서 사용하기


	예제1 : 
		def other_method(a):
		    print(a)
		    
		val = other_method  # 함수를 val이라는 변수에 담는다.
		other_method(123)
		val(123)





문제 65. 위에서 만든 init_network()함수안에 키 w1,w2,w3의 값을 변수 w1,w2,w3에 담으시오 !

	def init_network():
	    import numpy as np
	    network = {}
	    network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
	    network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
	    network['w3'] = np.array([[4, 6], [5, 7]])
	    return network
	
	w1, w2, w3 = init_network()['w1'], init_network()['w2'], init_network()['w3']
	
	print(w1) 
	print(w2) 	
	print(w3)

	[[1 2]
	 [3 4]
	 [5 6]]
	[[3 5 7]
	 [4 6 8]]
	[[4 6]
	 [5 7]]



문제 66. 위의 코드를 가지고 어제 만든 3층 신경망 코드를 다시 작성하시오 !

	def init_network():
	    import numpy as np
	    network = {}
	    network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
	    network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
	    network['w3'] = np.array([[4, 6], [5, 7]])
	    return network
	
	w1, w2, w3 = init_network()['w1'], init_network()['w2'], init_network()['w3']
	
	def sigmoid(data):
	    return 1/( 1 + np.exp(-data) )
	
	def identify_func(x):
	    return x
	
	def relu(x):
	    return np.maximum(0,x)
	
	# 0층 (입력층)
	x = np.array([1, 2])
	
	# 1층 (은닉 1층)
	y = np.dot(x,w1.T)
	y_hat = relu(y)
	
	# 2층 (은닉 2층)
	z = np.dot(y_hat,w2.T)
	z_hat = relu(z)
	
	# 출력층
	j = np.dot(z_hat, w3.T)
	j_hat = identify_func(j)
	print(j_hat)

	[2088 2499]





★ 신경망 안에 들어가는 함수들 

	1. 가중치를 만드는 함수 : init_network()
	2. 순전파 시키는 함수 : forward()
	3. 역전파 시키는 함수 : backward()
	4. 활성화 함수들 : sigmoid(), relu(), step_func()
	5. 출력층 함수들 : identity_func(), softmax()
	6. 오차 함수들 : 평균오차함수(회귀분석), 교차엔트포리 함수(분류문제)




문제 67. 입력층, 은닉1층, 은닉2층, 출력층 코드를 가지고 network과 입력값 x를 매개변수로 받는 
	 forward(network, x)라는 함수를 생성하시오 !

	def init_network():
	    import numpy as np
	    network = {}
	    network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
	    network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
	    network['w3'] = np.array([[4, 6], [5, 7]])
	    return network
	
	def sigmoid(data):
	    return 1/( 1 + np.exp(-data) )
	
	def identify_func(x):
	    return x
	
	def forword(network, x):
	    w1, w2, w3 = network['w1'], network['w2'], network['w3']
	    # 1층 (은닉 1층)
	    y = np.dot(x,w1.T)
	    y_hat = sigmoid(y)
	
	    # 2층 (은닉 2층)
	    z = np.dot(y_hat,w2.T)
	    z_hat = sigmoid(z)
	
	    # 출력층
	    j = np.dot(z_hat, w3.T)
	    j_hat = identify_func(j)
	    return j_hat
	
	
	# 실행 코드 
	network = init_network()   #가중치 생성
	x = np.array([1, 2])       #입력값
	print(forword(network, x)) # 순전파




문제 68. 입력값이 1, 2가 아니라 4, 5일때의 위의 3층 신경망을 통과한 결과를 아래와 같이 출력되게 하시오 !

	import layers_3 as la
	import numpy as np

	network = la.init_network()   #가중치 생성
	x = np.array([4, 5])          #입력값
	print(la.forword(network, x)) # 순전파






★ 출력층 함수 소프트 맥스 함수

	"분류를 위한 출력층 함수인데 0 ~ 1 사이의 숫자를 출력하는 함수"

	"순전파로 흘러왔던 확률(숫자)를 가지고 결론을 내주는 함수"

	결론이 뭐냐면 ? 개와 고양이 분류라면 개인지 고양이인지 결론을 내준다.

	정상폐, 폐결절, 폐결핵, 중 3개중 어떤 사진인지 결론을 내야 한다면 이 3개중 한가지로 결론을 내려주는
	함수

		그림 3-_-12


	소프트 맥스 함수 수학식을 컴퓨터 코드로 구현할때 주의사항 ?

		소프트 맥스 함수는 지수 함수를 사용하는데 이 지수함수 라는것이 쉽게 아주 큰 값을 내뱉는다.
		e (스위스의 수학자 오일러가 발견한 무리수)의 10승은 20,000이 넘고 e의 100승은 숫자가
		40개가 넘고 e의 1000승은 무한대를 뜻하는 inf가 출력되어 돌아오므로 컴퓨터로 계산을 할 수
		없다.


문제 69. 아래의 리스트를 무리수(자연상수)의 제곱으로 해서 계산값이 무엇인가 ?

	import numpy as np
	
	a = np.array([1010, 1000, 990])
	print(np.exp(a))
	
	[ inf  inf  inf]



	
문제 70. a리스트에서 각 요소값을 가장 큰 요소의 값으로 뺀 결과를 출력하시오 !

	import numpy as np
	
	a = np.array([1010, 1000, 990])
	c = np.max(a)
	print(c)
	print(a - c)

	1010
	[  0 -10 -20]
	


문제 71. 위의 [0 -10 -20]을 자연상수 e의 제곱으로 해서 출력된 결과가 무엇인지 확인하시오 !

	import numpy as np
	
	a = np.array([1010, 1000, 990])
	c = np.max(a)
	minus = a - c
	
	print(np.exp(minus))
	
	[  1.00000000e+00   4.53999298e-05   2.06115362e-09]



문제 72. 위의 코드를 softmax라는 함수 이름으로 만드시오 !

	import numpy as np
	a = np.array([1010, 1000, 990])
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    return np.exp(minus)
	
	print(softmax(a))

	[  1.00000000e+00   4.53999298e-05   2.06115362e-09]



문제 73. softmax 함수를 분모까지 포함해서 완전히 완성하시오 !

	import numpy as np
	a = np.array([1010, 1000, 990])
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    exp_a = np.exp(minus)
	    sum_exp_a = np.sum(exp_a)
	    return exp_a / sum_exp_a
	
	print(softmax(a))
	
	[  9.99954600e-01   4.53978686e-05   2.06106005e-09]



 오늘의 마지막 문제
문제 74. 위의 출력된 결과의 합이 1인지 확인하시오 !

	import numpy as np
	a = np.array([1010, 1000, 990])
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    exp_a = np.exp(minus)
	    sum_exp_a = np.sum(exp_a)
	    return exp_a / sum_exp_a
	
	print(np.sum(softmax(a)))
	
	1.0















