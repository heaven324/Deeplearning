■ 어제 배웠던 CNN복습
	1. CNN을 배워야 하는 이유?

		"기존층(완전연결계층)의 문제점을 극복하기 위해서"
					  ↓
				"이미지의 형상을 무시한다."

		사진을 사진 자체로 인식하게끔 컴퓨터에게 알려주는 방법이 CNN이다.
			1. Convolution계층 ──▶ 이미지의 특징을 잡아내는 역할
			2. pooling 계층    ──▶ 흐릿한 이미지를 진하고 뚜렷하게 만들어주는 역할





■ 3차원 합성곱 ( p 235 )

	이미지의 색깔이 보통은 흑백이 아니라 RGB 컬러이므로 RGB(Red, Green, Blue)컬러에 합성곱을 해야한다.

	그림 7-_-5



문제 208. 레드벨벳의 아이린 사진을 3차원 행렬로 변환하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	##5.1. 원본 이미지 불러오기
	
	img = Image.open('c://test_pic.jpg')
	img_pixel = np.array(img)
	plt.imshow(img_pixel)
	print (img_pixel) 

	[[[ 79  96 104]
	  [113 118 138]
	  [147 137 172]
	  ..., 
	  ..., 
	  [165 150 147]
	  [176 160 160]
	  [184 168 169]]]  ──▶ 픽셀 하나의 숫자가 0 ~ 255사이로 나타낼 수 있고 숫자가 클 수록
	    ↑  ↑   ↑		  밝은 색이다.
	   Red Green Blue




문제 209. 아이린 사진을 numpy배열로 변환한 행렬의 shape를 확인하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	img = Image.open('c://test_pic.jpg')
	img_pixel = np.array(img)
	# plt.imshow(img_pixel)
	print (img_pixel.shape)

	(500, 500, 3)
	 ↑   ↑   ↑
        가로 세로 색상		색상 : 0 ─▶ Red, 1 ─▶ Green, 2 ─▶ Blue




문제 210. 아이린 사진에서 red부분의 행렬만 추력하고 red부분만 이미지로 시각화 하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	img = Image.open('c://test_pic.jpg')
	img_pixel = np.array(img)
	plt.imshow(img_pixel[:, :, 0])
	plt.show()
	# print (img_pixel.shape)

	그림 7-_-6




문제 211. 아이린 사진의 Blue행렬을 시각화 하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	img = Image.open('c://test_pic.jpg')
	img_pixel = np.array(img)
	plt.imshow(img_pixel[:, :, 2])
	plt.show()

	그림 7-_-7




문제 212. 아래의 3차원 행렬을 시각화 하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]]], dtype=np.uint8)
	print(Filter.shape)
	plt.imshow(Filter)
	
	그림 7-_-8




문제 213. 위의 Filter 이미지에 Red부분행렬만 시각화하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]]], dtype=np.uint8)
	print(Filter[:, :, 0])
	plt.imshow(Filter[:, :, 0])

	그림 7-_-9




문제 214. R, G, B 행렬을 이해하기 위해 아래의 numpy array를 이해하시오 !

	import numpy as np
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	
	print(data.shape)
	
	(3,    5,   5)
	 ↑   ↑   ↑
        가로 세로 색상





문제 215. 위의 3차원 행렬의 이미지를 확인하시오 !

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	
	print(data.shape)
	print(data[0, :, :].T)
	plt.imshow(data.T[:, :, 0])
	
	(3, 5, 5)
	[[2 0 0 1 1]
	 [2 0 2 2 0]
	 [1 1 0 1 1]
	 [1 0 0 1 0]
	 [0 0 1 1 1]]

	그림 7-_-10




문제 216. 문제 210에서 만든 Filter 이미지 행렬을 이해하기 쉽도록 만든 문제 266번 형태로 변경하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]],
	                   [[255,255,255],
	                    [255,255,255],
	                    [0,0,0],
	                    [255,255,255],
	                    [255,255,255]]], dtype=np.uint8)
	Filter = Filter.T
	print(Filter)
	plt.imshow(Filter.T)
	
	[[[255 255   0 255 255]
	  [255 255   0 255 255]
	  [  0   0   0   0   0]
	  [255 255   0 255 255]
	  [255 255   0 255 255]]
	
	 [[255 255   0 255 255]
	  [255 255   0 255 255]
	  [  0   0   0   0   0]
	  [255 255   0 255 255]
	  [255 255   0 255 255]]
	
	 [[255 255   0 255 255]
	  [255 255   0 255 255]
	  [  0   0   0   0   0]
	  [255 255   0 255 255]
	  [255 255   0 255 255]]]




문제 217. 아래의 이미지를 출력하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,0,0],
	                    [255,0,0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]]], dtype=np.uint8)
	
	plt.imshow(Filter)

	그림 7-_-11




문제 218. 위의 코드를 이용해서 이번에는 Red가 아니라 Green으로 십자가 모양의 그림이 출력되게 하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,0,0],
	                    [255,0,0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]]], dtype=np.uint8)
	Filter = Filter.T
	Filter1 = np.array([Filter[1], Filter[0], Filter[2]])
	plt.imshow(Filter1.T)
	
	그림 7-_-12




문제 219. 십자가 모양을 Blue로 출력하시오 !

	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	Filter = np.array([[[255,0,0],
	                    [255,0,0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0],
	                    [0,0,0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]],
	                   [[255,0,0],
	                    [255, 0, 0],
	                    [0,0,0],
	                    [255, 0, 0],
	                    [255, 0, 0]]], dtype=np.uint8)
	Filter = Filter.T
	Filter1 = np.array([Filter[1], Filter[2], Filter[0]])
	plt.imshow(Filter1.T)
	
	그림 7-_-13




문제 220. 아이린 사진의 Red를 출력하시오 !
	 아이린 사진의 Red행렬만 그대로 두고 아이린 사진의 Green과 Blue로 변경해서 시각화 하시오 !
	
	from PIL import Image
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	img = Image.open('c://test_pic.jpg')
	img_pixel = np.array(img)
	img_pixel.T[1] = 0
	img_pixel.T[2] = 0
	plt.imshow(img_pixel)

	그림 7-_-14









☆ zero 패딩한 결과 
	입력 행렬에 제로패딩을 해서 출력층을 구현하는 것이다.

                     0 0 0 0 0 0
  1  2  3  0         0 1 2 3 0 0                           
  0  1  2  3    ---> 0 0 1 2 3 0  ◎  2 0 1   =   ?  
  3  0  1  2         0 3 0 1 2 0      0 1 2
  2  3  0  1         0 2 3 0 1 0      1 0 2 
                     0 0 0 0 0 0

    (4 x 4)            (6X6)         (3x3)       ( 4 x 4 ) 




문제 221. 아래의 RGB 3차원 행렬을 zero패딩 1 한 결과를 출력하시오 !

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
        	 [[4, 2, 1, 2,2],
        	  [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	print(data_pad)

	[[[0 0 0 0 0 0 0]
	  [0 2 2 1 1 0 0]
	  [0 0 0 1 0 0 0]
	  [0 0 2 0 0 1 0]
	  [0 1 2 1 1 1 0]
	  [0 1 0 1 0 1 0]
	  [0 0 0 0 0 0 0]]
	
	 [[0 0 0 0 0 0 0]
	  [0 2 0 0 0 1 0]
	  [0 0 2 2 0 1 0]
	  [0 0 0 0 0 2 0]
	  [0 0 1 2 0 1 0]
	  [0 2 0 2 2 2 0]
	  [0 0 0 0 0 0 0]]
	
	 [[0 0 0 0 0 0 0]
	  [0 4 2 1 2 2 0]
	  [0 0 1 0 4 1 0]
	  [0 3 0 6 2 1 0]
	  [0 4 2 4 5 4 0]
	  [0 0 1 2 0 1 0]
	  [0 0 0 0 0 0 0]]]




문제 222. 문제 220번의 결과인 아래의 Red행렬 에서 아래의 행렬만 추출하시오 !
	  [[0 0 0 0 0 0 0]
	   [0 2 2 1 1 0 0]
	   [0 0 0 1 0 0 0]
	   [0 0 2 0 0 1 0]
	   [0 1 2 1 1 1 0]
	   [0 1 0 1 0 1 0]
	   [0 0 0 0 0 0 0]]
	
	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	print(data_pad[0, 0:3, 0:3])
	
	[[0 0 0]
	 [0 2 2]
	 [0 0 0]]




문제 223. 문제 221번에서는 Red행렬에 대해서만 결과를 추출 했는데 아래와 같이 Green과 Blue도 다 추출 하시오 !

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	print(data_pad[0, 0:3, 0:3])
	print(data_pad[1, 0:3, 0:3])
	print(data_pad[2, 0:3, 0:3])

	[[0 0 0]
	 [0 2 2]
	 [0 0 0]]
	[[0 0 0]
	 [0 2 0]
	 [0 0 2]]
	[[0 0 0]
	 [0 4 2]
	 [0 0 1]]




문제 224. 아래의 Filter에서 Red행렬만 추출하시오 !

	import numpy as np
	
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	print(Filter[0])
	
	[[ 1  1 -1]
	 [-1  0  0]
	 [ 1  1  0]]




문제 225. 위의 원본 이미지(data) 행렬중 Red행렬과 Filter의 Red행렬과의 곱을 아래와 같이 수행하시오 !

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	
	print(data_pad[0, :3, :3]*Filter[0])
	
	[[0 0 0]
	 [0 0 0]
	 [0 0 0]]




문제 226. 아래의 원본 이미지 RGB 3개의 행렬과 아래의 필터 RGB 3개의 행렬을 각각 행렬곱 한 후 그 원소들을
	  다 합친 결과 숫자 하나를 출력하시오 !

	 [[0 0 0]         1  1 -1     0  0  0
	  [0 2 2]     *  -1  0  0  =  0  0  0
	  [0 0 0]]        1  1  0     0  0  0
	
	 [[0 0 0]        -1 -1  0     0  0  0
	  [0 2 0]     *   0 -1  1  =  0 -2  0
	  [0 0 2]]        0 -1  0     0  0  0 
	
	 [[0 0 0]        -1  1  1     0  0  0
	  [0 4 2]     *  -1  1 -1  =  0  4  -2
	  [0 0 1]]        0  0 -1     0  0  -1
	
	 결과 : - 1
	
	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	       	   [4, 2, 4, 5,4],
	       	   [0, 1, 2, 0, 1]]
	       ])
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	
	res = 0
	for i in range(3):
	    res += np.sum(data_pad[i, :3, :3]*Filter[i])
	    
	print(res)

	-1




문제 227. (점심시간 문제) 위의 원본 이미지(RGB)와 Filter(RGB)와의 3차원 합성곱을 한 결과를 출력하시오 !

	그림 7-_-15

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	data_pad = data
	data_pad = np.pad(data, pad_width = 1, mode = 'constant', constant_values=0)[1:4]
	
	result = []
	for i in range(data_pad.shape[1]-Filter.shape[1]+1):
	    for j in range(data_pad.shape[2]-Filter.shape[2]+1):
	        res = 0
	        for k in range(3):
	            res += np.sum(data_pad[k, i:Filter.shape[1]+i, j:Filter.shape[2]+j]*Filter[k])
	        result.append(res)
	result = np.array(result).reshape(data.shape[1:])
	print(result)
	plt.imshow(result)
	plt.show()




☆ 지금까지 한 핵심

	     5 x 5  ------>  convolution 층 ----->  5 x 5  
	
	  입력 이미지              ↓               출력 이미지
	                      stride :  1
	                     zero padding : 1 
	 
	                        0 0 0 0 0 0 0
	 [[2, 2, 1, 1, 0],      0 2 2 1 1 1 0
	  [0, 0, 1, 0, 0],      0 0 0 1 0 0 0      1,1,-1
	  [0, 2, 0, 0, 1],  --> 0 0 2 0 0 1 0   * -1,0, 0   =    ?  
	  [1, 2, 1, 1, 1],      0 1 2 1 1 1 0      1,1, 0
	  [1, 0, 1, 0, 1]],     0 1 0 1 0 1 0
	                        0 0 0 0 0 0 0  
	
	    5 x  5                7 x 7            3 x 3       5 x 5 

	입력할 때의 shape 5x5와 똑같이 5x5행렬로 출력 하려면 입력할 때 zero패딩을 1을 해줘야 한다.

		      H + 2P -FH	   5 + 2x1 - 3
		OH =  ────── + 1  =  ────── + 1   =   5
			  S		         1

		      W + 2P -FW	   5 + 2x1 - 3
		OW =  ────── + 1  =  ────── + 1   =   5
			  S		         1




문제 228. 아래와 같이 입력행렬과 필터행렬과 스트라이드와 패딩을 입력받아 출력 행렬의 shape를 출력하는
	  함수를 생성하시오 !

	x = np.array([[[2, 2, 1, 1, 0], 
	               [0, 0, 1, 0, 0], 
	               [0, 2, 0, 0, 1], 
	               [1, 2, 1, 1, 2], 
	               [1, 0, 1, 0, 1]],
	              [[2, 0, 0, 0, 1], 
	               [0, 2, 2, 0, 1], 
	               [0, 0, 0, 0, 2], 
	               [0, 1, 2, 0, 1], 
	               [2, 0, 2, 2, 2]],
	              [[1, 1, 0, 1, 1], 
	               [0, 1, 0, 1, 2], 
	               [0, 2, 2, 0, 0], 
	               [0, 2, 0, 0, 1], 
	               [1, 1, 2, 1, 1]]])
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	
	def output_size(data, Filter, stride, padding):
	    return int(((data.shape[1] + 2*padding - Filter.shape[1])/ stride ) +1)
	
	print(output_size( x, Filter, 1, 1))

	5




지금까지의 내용 정리 :

	원본이미지 1장  *  필터 50개   ───▶  feature map의 갯수 ( 50개 )
	    (7x7)	     (3x3)			(5x5)










★ 블록으로 생각하기 ( p 237 )
	3차원 합성곱 연산은 데이터와 필터를 직육면체 블럭이라고 생각하면 쉽다.
	블럭은 3차원 직육면체(채널, 높이, 너비)로 구성됨
			       C      H     W
	
	그림 7-_-16

	필터의 채널 (FC), 필터의 높이(FH), 필터의 너비(FW)
	설명 : 아이린 사진 한장(RGB) 를 RGB필터 1개로 합성곱해서 2차원 출력행렬(feature map) 1장을 
	       출력한 그림

					↓

		위의 그림은 feature map이 한개가 나오고 있는데 실제로는 아이린 사진 한장에 대해서
		여러개의 feature map이 필요하다.
		그러면 여러개의 feature map을 출력하려면 어떻게 해야 하는가?

					↓

			     "Filter의 갯수를 늘린다."

					↓
				그림 7-_-17





문제 229. 설현사진 50장과 아이린 사진 50장, 총 100장의 사진을 신경망에 입력해서 설현과 아이린을 
	  구분(분류)하는 신경망을 만든다고 할 때 RGB필터를 30개를 사용하면 출력 feature map이 총 몇개일까?

		100장 ───▶  conv층  ───▶  3000개

	합성곱 연산에서도 편향이 쓰이므로 편향을 더하면 어떤 그림일까 ? 
		그림 7-_-18











★ 배치처리 ( p 239 )

	위의 그림은 이미지를 1장씩 넣어서 학습시키므로 학습속도가 느리다. 그래서 여러장의 이미지를 
	한번에 입력해서 학습시키면 (mini batch)아래의 그림이 된다.
				↓
			그림 7-_-19

	아이린 사진 10장 ──▶  필터의 갯수 100개면 ──▶  (10, 100, 5, 5)
								   ↓
						아이린 사진 1장당 만들어지는 100개의 feature map이 
						10개가 생성됨

	그러면 결국 합성곱 계층을 구현할 때 흘러가는 행렬이 4차원 행렬이 흘러가면서 연산이 될 것인데
	그러면 문제가 연산속도가 느리므로 행렬 계산을 할 때 행렬 연산을 빠르게 하려면 4차원이 아니라
	2차원으로 차원축소가 필요하다.
	그래서 필요한 함수 ?
		"im2col 함수"  ◀── p 234
		     ↓
		4차원 ──▶ 2차원







★  im2col 함수의 역할을 그림으로 표현 ( p 234 )




문제 230. 칠판에 나온 아이린 사진 한장의 3차원 행렬을 만드시오 (RGB의 7x7 행렬 1장)

	import numpy as np
	
	x1 = np.random.rand(1, 3, 7, 7)
	print(x1)
	print(x1.shape)




문제 231. im2col함수를 이용해서 아래의 4차원을 2차원행렬로 변경하시오 ! ( 필터는 5x5의 RGB행렬을 사용함)

	def im2col(input_data, filter_h, filter_w, stride=1, pad=0):
	    """다수의 이미지를 입력받아 2차원 배열로 변환한다(평탄화).
	
	    Parameters
	    ----------
	    input_data : 4차원 배열 형태의 입력 데이터(이미지 수, 채널 수, 높이, 너비)
	    filter_h : 필터의 높이
	    filter_w : 필터의 너비
	    stride : 스트라이드
	    pad : 패딩
	
	    Returns
	    -------
	    col : 2차원 배열
	    """
	    N, C, H, W = input_data.shape
	    out_h = (H + 2 * pad - filter_h) // stride + 1
	    out_w = (W + 2 * pad - filter_w) // stride + 1
	
	    img = np.pad(input_data, [(0, 0), (0, 0), (pad, pad), (pad, pad)], 'constant')
	    col = np.zeros((N, C, filter_h, filter_w, out_h, out_w))
	
	    for y in range(filter_h):
	        y_max = y + stride * out_h
	        for x in range(filter_w):
	            x_max = x + stride * out_w
	            col[:, :, y, x, :, :] = img[:, :, y:y_max:stride, x:x_max:stride]
	
	    col = col.transpose(0, 4, 5, 1, 2, 3).reshape(N * out_h * out_w, -1)
	    return col
	
	import numpy as np
	
	x1 = np.random.rand(1, 3, 7, 7)
	col = im2col(x1, 5, 5, stride=1, pad=0)
	print(col.shape)

	(9, 75)




문제 232. 아이린 사진 10장을 im2col 함수에 넣어서 2차원 행렬로 변환시키시오 ! 
	  ( 필터는 5x5의 RGB 행렬을 사용함 )

	import numpy as np
	
	x1 = np.random.rand(10, 3, 7, 7)
	col = im2col(x1, 5, 5, stride=1, pad=0)
	print(col.shape)

	(90, 75)






★ 필터 RGB행렬을 2차원으로 푸는 방법

	1. 원본 이미지를 필터 사이즈에 맞게 2차원으로 변경한 행렬
		( 10, 3, 7, 7 ) ─────▶ ( 90, 75 )
				im2col 함수

	2. 4차원 필터 행렬을 2차원으로 변경
		(10, 3, 5, 5 ) ─────▶ (75, 10)
			reshape 함수의 -1을 이용




문제 233. 아래의 Filter를 생성하고 shape를 확인하고서 전치시키시오 !

	Filter = np.array([[[255,255,255],[255,255,255],[0,0,0],[255,255,255],[255,255,255]],
	                   [[255,255,255],[255,255,255],[0,0,0],[255,255,255],[255,255,255]],
	                   [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],
	                   [[255,255,255],[255,255,255],[0,0,0],[255,255,255],[255,255,255]],
	                   [[255,255,255],[255,255,255],[0,0,0],[255,255,255],[255,255,255]]], dtype  = np.uint8)
	print(Filter.shape)
	print(Filter.T.shape)

	(5, 5, 3)
	(3, 5, 5)



문제 234. Filter (3, 5 ,5) 행렬을 (3, 25) 행렬로 변경하시오 !

	a = Filter.T.reshape(3,-1)
	print(a.shape)
	print(a)

	(3, 25)
	[[255 255   0 255 255 255 255   0 255 255   0   0   0   0   0 255 255   0
	  255 255 255 255   0 255 255]
	 [255 255   0 255 255 255 255   0 255 255   0   0   0   0   0 255 255   0
	  255 255 255 255   0 255 255]
	 [255 255   0 255 255 255 255   0 255 255   0   0   0   0   0 255 255   0
	  255 255 255 255   0 255 255]]




문제 235. 아래의 4차원 행렬의 filter를 numpy의 random을 이용해서 만드시오 !
	( 10, 3, 5, 5) ◀─── 4차원 행렬 ( RGB 5x5 필터 10개 )

	import numpy as np
	
	Filter2 = np.random.rand(10, 3, 5, 5)
	print(Filter2.shape)

	(10, 3, 5, 5)





문제 236. 아래의 4차원 행렬을 3차원으로 변경하시오 !

	import numpy as np
	
	Filter2 = np.random.rand(10, 3, 5, 5)
	print(Filter2.shape)
	print(Filter2.reshape(10,3,-1).shape)

	(10, 3, 5, 5)
	(10, 3, 25)




문제 237. 아래의 3차원 행렬을 2차원 행렬로 변경하시오 !
	 (10, 3, 25) ───▶ (10, 75)
	    3차원 		2차원

	import numpy as np
	
	Filter2 = np.random.rand(10, 3, 5, 5)
	
	Filter3 = Filter2.reshape(10,3,-1)
	print(Filter3.reshape(10,-1).shape)
	
	(10, 75)





문제 238. 아래의 2차원을 1차원 행렬로 변경하시오 !
	 (10, 75) ───▶ (750, )
	   2차원 	    1차원
	
	import numpy as np
	
	Filter2 = np.random.rand(10, 3, 5, 5)
	Filter3 = Filter2.reshape(10,3,-1)
	Filter4 = Filter3.reshape(10,-1)
	print(Filter4.reshape(-1).shape)
	
	(750,)




문제 239. 다음을 계산하여라 !
	x = [ 0 ,0 ,0 ,0 ,2 ,2 ,0 ,0 ,0 , 0 ,0 ,0 ,0 ,2 ,0 ,0 ,0 ,2 ,0 ,0 ,0 ,0 ,4 ,2 ,0 ,0  ,1  ]  
	y = [ 1, 1, -1, -1, 0, 0, 1, 1, 0, -1, -1, 0, 0, -1, 1, 0, -1, 0, -1,1,1,-1,1,- 1,0,0,-1]
	x = np.array(x).reshape(1,27)
	y = np.array(y).reshape(1,27)
	print(np.dot(x, y.T))

	[[-1]]





문제 240. 아래의 입력값과 Filter행렬을 점심시간 문제로 3차원 합성곱을 했었다. 그래서 결과가 아래와 
	  같이 나왔다. 그런데 이번에는 3차원 합성곱하지 말고 차원을 축소시켜서 아래의 결과를 출력하시오 !
	  (오늘의 마지막 문제)

	import numpy as np
	
	data = np.array(
	       [
	         [[2, 2, 1, 1, 0],
	          [0, 0, 1, 0, 0],
	          [0, 2, 0, 0, 1],
	          [1, 2, 1, 1, 1],    #  --->  Red 
	          [1, 0, 1, 0, 1]],
	         [[2, 0, 0, 0, 1],
	          [0, 2, 2, 0, 1],
	          [0, 0, 0, 0, 2],    # ---->  Green
	          [0, 1, 2, 0, 1],
	          [2, 0, 2, 2, 2]],
	         [[4, 2, 1, 2,2],
	          [0, 1, 0, 4,1],      # ---->  Blue
	          [3, 0, 6, 2,1],
	          [4, 2, 4, 5,4],
	          [0, 1, 2, 0, 1]]
	       ])
	Filter=np.array([[[1,1,-1,-1,0,0,1,1,0],   \
	                  [-1,-1,0,0,-1,1,0,-1,0], \
	                  [-1,1,1,-1,1,-1,0,0,-1]]]).reshape(3,3,3)
	
	data_im = im2col(data.reshape(1, 3, 5, 5), Filter.shape[2], Filter.shape[1], stride=1,pad=1)
	Filter2 = Filter.reshape(3,-1).reshape(-1).reshape(1,27)
	result = np.dot(data_im, Filter2.T).reshape(5,5)
	print(result)
	plt.imshow(result)
	plt.show()

	[[ -1.  -7. -10.  -1.  -3.]
	 [  5.  -3.  -4.   7.  -5.]
	 [  3. -13.  -2.  -1.  -6.]
	 [  2.  -2.   2.  -9.  -6.]
	 [  2.   3.   7.   0.  -1.]]