■ 출력층 softmax함수 복습

	출력층 함수 2가지?

		1. 소프트 맥스 함수   -----> 분류를 목적으로 신경망을 구현
		2. 항등함수    ----->  회귀분석을 목적으로 신경망을 구현

	* 소프트 맥스 함수의 역할 ?

		" 0~1 사이의 확률값을 나타내서 가장 확률이 높은 것이 무엇인지 결론을 내려주는 역할"

		정상폐  1.2    -------> 소프트 맥스 ------>   0.46
		폐결절  0.9    -------> 소프트 맥스 ------>   0.34
		폐결핵  0.4    -------> 소프트 맥스 ------>   0.20

			정상폐 일 확률이 가장 높다라고 결론을 내려 줬다.



문제 76. 문제 75 번까지 해서 만들었던 3층 신경망(항등함수로 구현)의 출력층 함수를 소프트 맥스 함수로 
	 변경하시오 !

	import numpy as np
	
	def init_network():
	    network = {}
	    network['w1'] = np.array([[1, 2], [3 ,4], [5, 6]])
	    network['w2'] = np.array([[3, 5, 7], [4, 6, 8]])
	    network['w3'] = np.array([[4, 6], [5, 7]])
	    return network
	
	def sigmoid(data):
	    return 1/( 1 + np.exp(-data) )
	
	def identify_func(x):
	    return x
	
	def relu(x):
	    return np.maximum(0,x)
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    exp_a = np.exp(minus)
	    sum_exp_a = np.sum(exp_a)
	    return exp_a / sum_exp_a
	
	def forword(network, x):
	    w1, w2, w3 = network['w1'], network['w2'], network['w3']
	    # 1층 (은닉 1층)
	    y = np.dot(x,w1.T)
	    y_hat = sigmoid(y)
	
	    # 2층 (은닉 2층)
	    z = np.dot(y_hat,w2.T)
	    z_hat = sigmoid(z)
	
	    # 출력층
	    j = np.dot(z_hat, w3.T)
	    j_hat = softmax(j)
	    return j_hat
	
	# 실행 코드 
	network = init_network()   #가중치 생성
	x = np.array([1, 2])       #입력값
	print(forword(network, x)) # 순전파

	# layer_3모듈 수정완료


		※ 신경망   학습  -------> 소프트 맥스 함수를 사용 o
			   테스트 -------> 소프트 맥스 함수를 사용 x
			"자원 낭비를 줄이고자"




★ 출력층의 뉴런 수 구하기
							    출력층의 뉴런수 ?
	1. 분류하고자 하는 사진 개, 고양이 분류        ------>  2개
	2. 분류하고자 하는 사진 정상폐, 폐결절, 폐결핵 --------> 3개
	3. mnist 데이터 (필기체 숫자 0 ~ 9 까지의 사진) ---->  10개 






★ mnist(손글씨 필기체) 데이터를 파이썬으로 로드하는 방법

	1. 책 소스코드와 데이터를 다운로드 받는다. (dataset.zip)

	2. dataset이라는 폴더를 워킹 디렉토리에 가져다 둔다.
	   (실행하는 소스가 있는 디렉토리)

	3. 아래의 파이썬 코드를 실행해서 필기체 데이터 하나를 시각화 한다.

		# coding: utf-8
		
		import sys, os
		
		sys.path.append(os.pardir)  # 부모디렉토리의 파일을 가져올수 
		                            # 있도록 설정 
		
		import numpy as np
		from dataset.mnist import load_mnist
		from PIL import Image
		
		
		def img_show(img): # 이미지를 출력하는 함수 
		    pil_img = Image.fromarray(np.uint8(img))
		    # 파이썬 이미지 객체로 변환 
		    pil_img.show()  # pil_img 객체의 show 라는 메소드를 실행 
		
		(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)
		
		
		img = x_train[0]
		label = t_train[0]
		print(label)  # 5
		
		print(img.shape)  # (784,)
		img = img.reshape(28, 28)
		
		img_show(img)




문제 77. 아래의 코드의 dataset 패키지의 mnist.py에 load_mnist라는 함수가 있는지 확인하시오 !

	def load_mnist(normalize=True, flatten=True, one_hot_label=False):
	    """MNIST 데이터셋 읽기
	    
	    Parameters
	    ----------
	    normalize : 이미지의 픽셀 값을 0.0~1.0 사이의 값으로 정규화할지 정한다.
	    one_hot_label : 
	        one_hot_label이 True면、레이블을 원-핫(one-hot) 배열로 돌려준다.
	        one-hot 배열은 예를 들어 [0,0,1,0,0,0,0,0,0,0]처럼 한 원소만 1인 배열이다.
	    flatten : 입력 이미지를 1차원 배열로 만들지를 정한다. 
	    
	    Returns
	    -------
	    (훈련 이미지, 훈련 레이블), (시험 이미지, 시험 레이블)
	    """
	    if not os.path.exists(save_file):
	        init_mnist()
	        
	    with open(save_file, 'rb') as f:
	        dataset = pickle.load(f)
	    
	    if normalize:
	        for key in ('train_img', 'test_img'):
	            dataset[key] = dataset[key].astype(np.float32)
	            dataset[key] /= 255.0
	            
	    if one_hot_label:
	        dataset['train_label'] = _change_one_hot_label(dataset['train_label'])
	        dataset['test_label'] = _change_one_hot_label(dataset['test_label'])    
	    
	    if not flatten:
	         for key in ('train_img', 'test_img'):
	            dataset[key] = dataset[key].reshape(-1, 1, 28, 28)
	
	    return (dataset['train_img'], dataset['train_label']), (dataset['test_img'], dataset['test_label']) 
	
	
	if __name__ == '__main__':
	    init_mnist()



문제 78. x_train데이터를 print해보시오 !

	# coding: utf-8
	
	import sys, os
	
	sys.path.append(os.pardir)  # 부모디렉토리의 파일을 가져올수 
	                            # 있도록 설정 
	
	import numpy as np
	from dataset.mnist import load_mnist
	from PIL import Image
	
	(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)
	
	print(x_train)

	[[0 0 0 ..., 0 0 0]
	 [0 0 0 ..., 0 0 0]
	 [0 0 0 ..., 0 0 0]
	 ..., 
	 [0 0 0 ..., 0 0 0]
	 [0 0 0 ..., 0 0 0]
	 [0 0 0 ..., 0 0 0]]



문제 79. x_train데이터가 6만장이 맞는지 확인하시오 !

	print(len(x_train))
	print(x_train.shape)
	print(x_train.ndim)
	
	60000
	(60000, 784)
	2



문제 80. 아래의 리스트를 numpy array리스트로 변경하시오 !

	import numpy as np
	
	x = [[0.1,0.05,0.1,0.0,0.05,0.1,0.0,0.1,0.0,0.0],
	     [0.1,0.05,0.2,0.0,0.05,0.1,0.0,0.6,0.0,0.0],
	     [0.0,0.05,0.3,0.0,0.05,0.1,0.0,0.6,0.0,0.0],
	     [0.0,0.05,0.4,0.0,0.05,0.0,0.0,0.5,0.0,0.0],
	     [0.0,0.05,0.5,0.0,0.05,0.0,0.0,0.4,0.0,0.0],
	     [0.0,0.05,0.6,0.0,0.05,0.0,0.0,0.3,0.0,0.0],
	     [0.0,0.05,0.7,0.0,0.05,0.0,0.0,0.2,0.0,0.0],
	     [0.0,0.1,0.8,0.0,0.1,0.0,0.0,0.2,0.0,0.0],
	     [0.0,0.05,0.9,0.0,0.05,0.0,0.0,0.0,0.0,0.0]]
	
	x = np.array(x)
	print(x)

	[[ 0.1   0.05  0.1   0.    0.05  0.1   0.    0.1   0.    0.  ]
	 [ 0.1   0.05  0.2   0.    0.05  0.1   0.    0.6   0.    0.  ]
	 [ 0.    0.05  0.3   0.    0.05  0.1   0.    0.6   0.    0.  ]
	 [ 0.    0.05  0.4   0.    0.05  0.    0.    0.5   0.    0.  ]
	 [ 0.    0.05  0.5   0.    0.05  0.    0.    0.4   0.    0.  ]
	 [ 0.    0.05  0.6   0.    0.05  0.    0.    0.3   0.    0.  ]
	 [ 0.    0.05  0.7   0.    0.05  0.    0.    0.2   0.    0.  ]
	 [ 0.    0.1   0.8   0.    0.1   0.    0.    0.2   0.    0.  ]
	 [ 0.    0.05  0.9   0.    0.05  0.    0.    0.    0.    0.  ]]



문제 81. 위의 numpy array로 변경한 리스트의 차원을 확인하시오 !

	print(x.ndim)
	
	2



문제 82. 위의 리스트를 1차원으로 변경하시오 !

	import numpy as np
	
	a = np.array(x)
	print(a.ndim)
	a2 = a.flatten()
	print(a2.ndim)

	2
	1



문제 83. mnist데이터를 load_mnist 함수로 로드할 때 flatten을 false로 해서 로드하고 훈련 데이터의 shape를 
	 확인해보시오 !

	# coding: utf-8
	
	import sys, os
	
	sys.path.append(os.pardir)  # 부모디렉토리의 파일을 가져올수 
	                            # 있도록 설정 
	
	import numpy as np
	from dataset.mnist import load_mnist
	from PIL import Image
	
	(x_train, t_train), (x_test, t_test) = load_mnist(flatten=False, normalize=False)
	
	
	print(len(x_train))
	print(x_train.shape)
	print(x_train.ndim)
	
	60000
	(60000, 1, 28, 28)
	       ↑  ↑  ↑
	     흑백 가로 세로	컬러면 ?  RGB값으로 해서 3이 출력됨.
	4




문제 84. x_train[0]이 숫자 4였는데 x_train[0]의 라벨(정답) 인 t_train[0]을 출력해서 숫자 5가 맞는지 확인하시오 !

	# coding: utf-8
	
	import sys, os
	
	sys.path.append(os.pardir)  # 부모디렉토리의 파일을 가져올수 
	                            # 있도록 설정 
	
	import numpy as np
	from dataset.mnist import load_mnist
	from PIL import Image
	
	(x_train, t_train), (x_test, t_test) = load_mnist(flatten=False, normalize=False)
	
	print(t_train[0])
	
	5


문제 85. t_train 데이터를 출력할 때 one_hot_encoding을 True로 해서 출력하시오 !

	# coding: utf-8
	
	import sys, os
	
	sys.path.append(os.pardir)  # 부모디렉토리의 파일을 가져올수 
	                            # 있도록 설정 
	
	import numpy as np
	from dataset.mnist import load_mnist
	from PIL import Image
	
	(x_train, t_train), (x_test, t_test) = load_mnist(flatten=False, normalize=False, one_hot_label=True)
	
	print(t_train[0])
	
	[ 0.  0.  0.  0.  0.  1.  0.  0.  0.  0.]
	  0   1   2   3   4   5   6   7   8   9




문제 86. mnist 데이터를 가져오는 코드를 가지고 아래의 get_data()함수를 생성하고 아래와 같이 실행되게 하시오 !

	def get_data():
	    (x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)
	    return x_test, t_test
	x, t = get_data()
	
	print(x.shape)
	print(len(t))

	(10000, 784)
	10000






★ 필기체 데이터 60000장을 충분히 학습시키고 만들어낸 가중치 값을 (저자가 미리 생성함)을 init_network함수로
   가져오는 방법

	import pickle
	def init_network():
	    with open('sample_weight.pkl', 'rb') as f:
	        network = pickle.load(f)
	    return network
	
	network = init_network()
	print(network['W1'].shape)
	print(network['W2'].shape)
	print(network['W3'].shape)
	print(network['b1'].shape)
	print(network['b2'].shape)
	print(network['b3'].shape)

	(784, 50)
	(50, 100)
	(100, 10)
	(50,)
	(100,)
	(10,)



   * 훈련데이터의 행렬 모습이 60000x784인지 확인한다.

	(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)
	
	print(x_train.shape)

	(60000, 784)




★ 저자가 이미 최적화 해놓은 W1, W2, W3, b1, b2, b3를 가지고 만든 신경망 코드 

	import sys, os
	
	sys.path.append(os.pardir)
	
	import numpy as np
	from dataset.mnist import load_mnist
	from PIL import Image
	import  pickle
	import  numpy  as np
	
	# 신경망 함수들
	def sigmoid(num):
	    rst = (1 / (1 + np.exp(-num)))
	    return (rst)
	
	
	def identity_function(x):
	    return x
	
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    exp_a = np.exp(minus)
	    sum_exp_a = np.sum(exp_a)
	    y = exp_a / sum_exp_a
	    return y
	
	def  init_network():
	    with open("sample_weight.pkl",'rb')  as  f:
	        network = pickle.load(f)
	    return  network
	
	
	def  predict(network, x):
	    W1, W2, W3 = network['W1'], network['W2'], network['W3']
	    b1, b2, b3 = network['b1'], network['b2'], network['b3']
	
	    a1 = np.dot(x,W1) + b1
	    z1 = sigmoid(a1)
	    a2 = np.dot(z1,W2) + b2
	    z2 = sigmoid(a2)
	    a3 = np.dot(z2,W3) + b3
	    y = softmax(a3)
	
	    return  y
	
	def  get_data():
	    (x_train, t_train) , (x_test, t_test) = \
	    load_mnist(normalize=True, flatten=True, one_hot_label=False)
	    return  x_test, t_test
	
	x, t = get_data()
	network = init_network()
	y = predict(network,x[0])
	print(y)



문제 87. 자신이 만든 필기체 숫자를 784의 flatten된 numpy배열로 만드시오 !(오늘의 마지막 문제)

	import cv2
	j = 'tttt.png'
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.image as mpimg
	
	def rgb2gray(rgb):
	    return np.dot(rgb[...,:3], [0.299, 0.587, 0.114])
	
	img = mpimg.imread(j)
	gray = rgb2gray(img)

	#이미지프린트
	#plt.imshow(gray, cmap = plt.get_cmap('gray'))
	#plt.show()
	#print(gray.shape)

	a = np.array(gray)
	x= a.flatten()
	# print(x.shape)
	
	import sys, os
	
	sys.path.append(os.pardir)
	
	from dataset.mnist import load_mnist
	from PIL import Image
	import  pickle
	
	def sigmoid(num):
	    rst = (1 / (1 + np.exp(-num)))
	    return (rst)
	
	
	def identity_function(x):
	    return x
	
	
	def softmax(a):
	    c = np.max(a)
	    minus = a - c
	    exp_a = np.exp(minus)
	    sum_exp_a = np.sum(exp_a)
	    y = exp_a / sum_exp_a
	    return y
	
	def  init_network():
	    with open("sample_weight.pkl",'rb')  as  f:
	        network = pickle.load(f)
	    return  network
	
	
	def  predict(network, x):
	    W1, W2, W3 = network['W1'], network['W2'], network['W3']
	    b1, b2, b3 = network['b1'], network['b2'], network['b3']
	
	    a1 = np.dot(x,W1) + b1
	    z1 = sigmoid(a1)
	    a2 = np.dot(z1,W2) + b2
	    z2 = sigmoid(a2)
	    a3 = np.dot(z2,W3) + b3
	    y = softmax(a3)
	
	    return  y
	
	def  get_data():
	    (x_train, t_train) , (x_test, t_test) = \
	    load_mnist(normalize=True, flatten=True, one_hot_label=False)
	    return  x_test, t_test
	
	#x, t = get_data()
	network = init_network()
	y = predict(network,x)
	print(np.argmax(y))
	
