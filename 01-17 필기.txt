★ 3. 미니배치 (mini batch) 학습 (p 115)

	"훈련 데이터중에 일부만 골라서 학습하는 방법"
	"표본을 뽑아서 학습 시킨다."
		     ↓
	예 : 된장찌개의 맛을 확인하기 위해서 한수저만 간을 본다
					     (표본)

	복원추출이든 비 복원 추출이든 mnist의 경우 100장씩 배치처리한다면 100장씩 600번을 훈련시키면 그게
	1 epooch이다.
	
	여러번 에폭이 반복되면서 비용함수(오차함수)의 global minima로 찾아가게 된다.

	설명 :  복원추출?	한번 뽑은 것을 다시 뽑을 수 있는 추출

		비 복원 추출?   한번 뽑은 것을 다시 뽑을 수 없는 추출

		에폭 ? 		
			그림 4-_-3


문제 112. 1 ~ 60000개의 숫자중에 무작위로 10개를 출력하시오 !

	import numpy as np
	
	print(np.random.choice(np.arange(60000), 10))
	
	[58689 56878 34252 35130  5495 32837 58336 22841  1928 17641]




문제 113. mnist의 테스트 데이터 10000wnddp 랜덤으로 100장을 추출하는 코드를 작성하시오 !

	x, t = get_data()
	for i in range(0, 10000, 100):
	    batch_mask = np.random.choice(10000, 100)
	    print(batch_mask)
	    x_batch = x[batch_mask]
	    print(len(x_batch))




문제 114. 위의 코드는 복원추출인데 비복원 추출이 되게끔 코드를 수정하시오 !

	x, t = get_data()
	for i in range(0, 10000, 100):
	#     batch_mask = np.random.choice(10000, 100)
	#     print(batch_mask)
	#     x_batch = x[batch_mask]    # 복원 추출
	    x_batch = x[i:i+100]         # 비복원 추출
	    print([j for j in range(i, i+100)])
	    print(len(x_batch))



문제 115. 위의 코드를 5에폭 돌게 코드를 수정하시오 !

	x, t = get_data()
	for a in range(5):
	    for i in range(0, 10000, 100):
	    #     batch_mask = np.random.choice(10000, 100)
	    #     print(batch_mask)
	    #     x_batch = x[batch_mask]    # 복원 추출
	        x_batch = x[i:i+100]         # 비복원 추출
	        print([j for j in range(i, i+100)])
	        print(len(x_batch))







★ 미니 배치 처리에 맞게끔 교차 엔트로피 함수를 구성하는 방법

	- 미니 배치 처리하기 전 교차 엔트로피 함수 (1장씩 처리)

	y = np.array([0, 0, 0.9, 0, 0, 0, 0, 0, 0.1 ])
	t = np.array([0, 0, 1,   0, 0, 0, 0, 0, 0])
	
	def cross_entropy_error(x,t):
	    delta = 1e-7
	    return -np.sum(t*np.log(x+delta))
	
	print(cross_entropy_error(y,t))

	0.105360404547


	- 100장씩 



문제 116. 미니배치(100장)에 맞게끔 교차엔트로피 함수를 수정하시오 !

	def cross_entropy_error(x,t):
	    delta = 1e-7
	    return -np.sum(t*np.log(x+delta))/x.shape[0]






★ 수치 미분 ( p121 )

	신경망 학습 시킬 때 미분을 왜 알아야 하는가 ?
	가중치를 갱신해주기 위해서 미분이 필요하다.
	가중치 = 가중치 - 기울기

	한 점에서의 속도를 구하려면 접선의 방정식을 구해야 하는데 구하는 방법이 바로 미분(기울기)
			lim  ( f(x+h) - f(x) ) / h
			h→0

	위의 미분 공식을 파이썬 함수로 구현해서 실행을 해본다.

	import numpy as np
	print(np.float32(1e-50))
	0.0
	계산이 안되므로 h를 10의 -4승의 값을 사용하면 좋은 결과가 나온다고 알려져있다.

	1. 미분 함수의 첫번째 개선
		def numerical_diff(f,x):
		    h = 1e-4 # 0.0001, 컴퓨터로 는 극한값을 구하기 어려우므로
		    return (f(x+h) - f(x)) / h

		↓  컴퓨터로는 미분을 하지 못하니 도함수를 구현해야 한다.

	2. 두번째 개선

		접선의 공식				할선의 공식

		lim  ( f(x+h) - f(x) ) / h		lim  ( f(x+h) - f(x-h) ) / (x+h) - (x-h) 
		h→0					h→0
	
							lim  ( f(x+h) - f(x-h) ) / 2h 
							h→0

		def numerical_diff(f,x):
		    h = 1e-4
		    return (f(x+h) - f(x-h)) / 2h



문제 117. y=2x^2+2의 함수를 loss2라는 이름으로 생성하시오 !

	def loss2(x):
	    return 2(x**2) + 2

	print(loss2(4))
	34



문제 118.  y=2x^2 + 2 의 함수의 x = 7인 곳의 기울기를 손으로 구하시오 !
	기울기를 구하려면 도함수를 알아야한다
	도함수 ? 함수를 미분해서 얻은 함수

	y = 4x
		28 <---- 기울기



문제 119. y=2x^2 + 2 의 함수의 x = 7인 곳의 기울기를 구하시오 !

	def numerical_diff(f,x):
	    h = 1e-4
	    return (f(x+h) - f(x-h)) / (2*h)
	
	def loss2(x):
	    return 2*(x**2) + 2
	
	print(numerical_diff(loss2,7)) # 파이썬에서는 함수 안에 함수를 넣을 수 있다.

	27.999999999934744



문제 120. 문제 119번의 함수를 접선의 미분 공식으로 만든 함수로 미분했을 때의 x=7에서의 기울기를 구하시오 !

	def numerical_diff(f,x):
	    h = 1e-4 # 0에 가까운 숫자 0.000000.....1(0이 50개)
	    return (f(x+h) - f(x)) / h
	
	print(numerical_diff(loss2,7))

	28.000199999951292



































